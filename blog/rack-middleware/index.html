<!DOCTYPE html>
<html>
  <head>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-180348489-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-180348489-1');
    </script>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="x-ua-compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="QWmLu6t80Hd6FFgS7MaFl_UMcFLXqOLwd08_u-HXzsk">
    <meta name="description" content="An introduction on Ruby&#39;s Rack Middleware and how to build and mount couple of
them.">
    <meta name="author" content="Alberto Grespan">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@albertogg">
    <meta name="twitter:title" content="Rack middleware">
    <meta name="twitter:description" content="An introduction on Ruby&#39;s Rack Middleware and how to build and mount couple of
them.">
    <meta name="twitter:creator" content="@albertogg">
    <meta name="twitter:image" content="https://www.gravatar.com/avatar/006ef14fba8fadd40053ecda5039deb2.png?s=250">
    <title>Rack middleware &ndash; Alberto Grespan</title>
    <link href="https://fonts.googleapis.com/css?family=Merriweather:300,400,700,900" rel="stylesheet">
    
    <link rel="stylesheet" type="text/css" href="https://albertogrespan.com/site/scss/style.css">
  </head>
  <body>
    <div id="content-wrapper">
      <div class="header">
  <header class="container">
    <h1 class="name">
      <a href="https://albertogrespan.com">Alberto Grespan</a>
    </h1> 
    <ul class="menu">
      <li><a href="https://albertogrespan.com/about/">About</a></li>
      <li><a href="https://albertogrespan.com/resume/">Resume</a></li>
      <li><a href="https://albertogrespan.com/index.xml">RSS</a></li>
    </ul> 
  </header> 
</div> 

      
  <div id="post" class="post">
    <h1>Rack middleware</h1>
    <div class="date">
      <p>&mdash; January 31, 2015</p>
    </div> 
    
    <blockquote>
<p>tl;dr we are creating two Rack middlewares, one that adds a custom header to
all responses and one that adds a new route with a custom response.</p>
</blockquote>
<p>As explained in a previous post about <a href="http://albertogrespan.com/blog/rack-basics/">Rack basics</a>, Rack is found
on the most popular Ruby web frameworks, as it&rsquo;s an adaptable interface for
developing web applications. In this post we are going to create two simple
middlewares. The first one will add a custom header to all responses, the second
one will add a custom route that responds to <code>/ping</code> and to glue it all together
we are using <code>Rack::Builder</code>.</p>
<h2 id="things-to-know-about-rack-middleware">Things to know about Rack middleware</h2>
<p>There are few things that we need to know about Rack middleware in order to
fully understand how it works are:</p>
<ul>
<li>Each middleware responds to a <code>call()</code> method.</li>
<li>Only receives one argument, the environment (<code>env</code>).</li>
<li>Responds with an array of: Integer as status code, hash of headers and array
of strings as the body.</li>
<li>Each middleware is responsible of calling the next.</li>
</ul>
<p>Now that we know this, let&rsquo;s start writing the middleware.</p>
<h2 id="adding-a-custom-header">Adding a custom header</h2>
<p>For this first middleware we are going to add a custom header to all responses.
We&rsquo;ll be using the following header: <code>X-Custom-Header: customheader.v1</code>. We
could also use something like <code>Content-Type: application/json; charset=utf-8</code> if
we wanted to.</p>
<p><strong>note:</strong> our middleware will live in a <code>lib</code> directory.</p>
<pre><code># lib/custom_header.rb
module Rack
  class CustomHeader
    def initialize(app)
      @app = app
    end

    def call(env)
      status, headers, body = @app.call(env)

      headers['X-Custom-Header'] = &quot;customheader.v1&quot;

      [status, headers, body]
    end
  end
end
</code></pre>
<p>As explained in the section above, we are creating the <code>call()</code> method and
passing it the <code>env</code> argument. Inside this method we picking up the status,
headers and body from the <code>@app.call(env)</code>. Then appending our custom header to
the existing response headers and finally return the array of status code,
headers, and body.</p>
<p>We have our first middleware ready, let&rsquo;s go with the second one.</p>
<h2 id="adding-a-new-route">Adding a new route</h2>
<p>Inside this middleware we are adding a new route called <code>/ping</code>. This route will
respond with a <code>pong</code> text. How will this middleware work? It will check the
request path, if it&rsquo;s <code>/ping</code> it will respond if it doesn&rsquo;t, the call will pass
to the rest of the stack.</p>
<pre><code># lib/ping.rb
module Rack
  class Ping
    def initialize(app)
      @app = app
    end

    def call(env)
      req = Rack::Request.new(env).path
      if req == &quot;/ping&quot;
        [200, {}, [&quot;pong&quot;]]
      else
        @app.call(env)
      end
    end
  end
end
</code></pre>
<p>In the same way as with the <code>CustomHeader</code> middleware, there will be a <code>call()</code>
method with the <code>env</code> argument. Inside this method we&rsquo;ll check using
<code>Rack::Request</code> the path of the current request and generate the desired
response array with the status code, empty headers and a body of strings. Note
that if the route is not <code>/ping</code> we simply call <code>@app.call(env)</code> letting the
call go through the stack.</p>
<p>We could also read the request path like this: <code>if env[&quot;PATH_INFO&quot;] == &quot;/ping&quot;</code>
but I like using the <code>Rack::Request</code> interface.</p>
<p>Now let&rsquo;s glue the middleware to an application.</p>
<h2 id="rack-builder">Rack Builder</h2>
<p>According to the documentation is:</p>
<blockquote>
<p>Rack::Builder implements a small DSL to iteratively construct Rack
applications</p>
</blockquote>
<p>I can define this as the backbone that holds middlewares and applications
together into a single Rack application. With that said, what we need to
understand when we see <code>Rack::Builder.new</code> in an application, is that it&rsquo;s a
block that packs a bunch of middleware (defined by the <code>use</code> keyword) and an
application at the bottom (defined by the <code>run</code> keyword) into a single Rack
application <code>app</code> that will allow us to run the whole thing.</p>
<p>Let&rsquo;s give it a look&hellip;</p>
<pre><code># config.ru
$:.unshift File.expand_path('../lib', __FILE__)

require 'custom_header'
require 'ping'

app = Rack::Builder.new do
  use Rack::CustomHeader
  use Rack::Ping
  run Proc.new { |env| [200, {}, [&quot;Say something to me!&quot;]] }
end

run app
</code></pre>
<p>The first thing we do is loading the <code>lib</code> directory into the <code>$LOAD_PATH</code> and
require the two files that contain our middleware. Now that we know that our
middleware is available, we&rsquo;ll pack the application with <code>Rack::Builder.new</code> by
adding the middleware on the top and the application at the bottom. The final
step will be to run the new packed Rack app.</p>
<p>Let&rsquo;s try this running the <code>config.ru</code> and doing some requests with <code>cURL</code>.</p>
<p>Start the application using the <code>rackup</code> command.</p>
<pre><code>$ curl -i -X GET localhost:9292
HTTP/1.1 200 OK
X-Custom-Header: customheader.v1
Transfer-Encoding: chunked

Say something to me!
</code></pre>
<p>First we are trying the <code>&quot;/&quot;</code> route but it will be the same with any route as
our application responds to all routes. The response is the expected, as there
is our custom header and the application body.</p>
<p>But what happens if we use the <code>/ping</code> route:</p>
<pre><code>$ curl -i -X GET localhost:9292/ping
HTTP/1.1 200 OK
X-Custom-Header: customheader.v1
Transfer-Encoding: chunked

pong
</code></pre>
<p>One thing to notice is that this response apart from being from the Ping
middleware it also has our custom header, that&rsquo;s because the <code>CustomHeader</code>
middleware is before the <code>Ping</code> middleware and with middleware the order
matters. This will not happen if the order was different, so be careful when
you are setting up new middleware in the stack.</p>
<hr>
<p>This is a very simple example that shows how middleware are created and work. I
hope it&rsquo;s useful for some of you.</p>
<p>Thanks for reading!</p>

    <div class="closing">
      <div>
       By <a href="https://twitter.com/albertogg" class="twitter-follow-link">@albertogg</a>
      </div>
      <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-url="https://albertogrespan.com/blog/rack-middleware/" data-text="Rack middleware" data-via="albertogg" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    </div> 
  </div> 

    </div> 
    <footer id="footer">
  <div class="container">
    <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
    <p>2012 &#151; 2021 albertogrespan.com</p>
  </div> 
</footer> 

  </body>
</html>
